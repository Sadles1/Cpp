#include <windows.h>
#include <gdiplus.h>
#include <math.h>
#include <ctime>
#include <vector>
#include "resource.h"
#pragma comment(lib, "gdiplus.lib")

HWND hCombo1;
HANDLE event;

int NewNumberOfThreads = 1;
int NumberOfThreads = 0;
int CurrentSelectThread;

BOOL CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);

struct Thread
{
public:
	struct RGB
	{
		int R = rand() % 255;
		int G = rand() % 255;
		int B = rand() % 255;
	};
	RGB rgb;
	int Radius=rand()%50+10;
	HDC hdc;
};

std::vector <Thread> ThreadsInfo;

int CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow)
{
	Gdiplus::GdiplusStartupInput gdiplusstartupinput;
	ULONG_PTR gdiplusToken;
	Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusstartupinput, nullptr);
	DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_DIALOG1),0,(DlgProc),0);
	Gdiplus::GdiplusShutdown(gdiplusToken);
	return 0;
}

void Draw(HDC hdc,int R,int G,int B,int radius)
{
	POINT ptCenter;
	ptCenter.x = rand() % 670;
	ptCenter.y = rand() % 300;
	Gdiplus::Graphics gf(hdc);
	Gdiplus::Pen pen(Gdiplus::Color(255,R,G,B));
	Gdiplus::SolidBrush brush(Gdiplus::Color(255, R,G,B));
	Sleep(100);
	gf.FillEllipse(&brush, ptCenter.x, ptCenter.y, radius, radius);
}



DWORD WINAPI PaintCurcle(CONST LPARAM Info)
{
	CONST Thread* CurrentThreadInfo = (Thread*)Info;
	CONST HDC hdc = CurrentThreadInfo->hdc;
	int radius = CurrentThreadInfo->Radius;
	int R = CurrentThreadInfo->rgb.R;
	int G = CurrentThreadInfo->rgb.G;
	int B = CurrentThreadInfo->rgb.B;
	for (int i = 0; true; i++)
	{
		Sleep(100);
		Draw(hdc,R,G,B,radius);
	}
	return 0;
}


BOOL CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	std::vector <HANDLE> Threads;
	HDC hdc;
	PAINTSTRUCT ps;
	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			hCombo1 = GetDlgItem(hwnd, IDC_COMBO1);
			break;
		}
		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDC_COMBO1:
				{
					if (HIWORD(wParam) == CBN_SELENDOK)
					{
						CHAR str_1[255];
						int i = SendMessage(hCombo1, CB_GETCURSEL, 0, 0);
						SendMessage(hCombo1, CB_GETLBTEXT, i, (LPARAM)str_1);
						
					}
					break;
				}
				case IDNEWTHREAD:
				{
					NewNumberOfThreads++;
					NumberOfThreads++;
					INT value = NumberOfThreads;
					TCHAR text[1000];
					snprintf(text, sizeof text, "%i", value);

					SendMessage(hCombo1, CB_ADDSTRING, 0, (LPARAM)((LPSTR)text));
					InvalidateRect(hwnd, NULL, TRUE);
					break;
				}	
				case IDDELETETHREAD:
				{
					InvalidateRect(hwnd, NULL, TRUE);
					break;
				}
			}
			break;
		}
		case WM_PAINT:
		{
			srand(time(NULL));
			hdc = BeginPaint(hwnd, &ps);
			for (int i = 0; i < NewNumberOfThreads; i++)
			{
				Thread CurrentThreadInfo;
				CurrentThreadInfo.hdc = hdc;
				CurrentThreadInfo.Radius = rand() % 50+10;
				ThreadsInfo.push_back(CurrentThreadInfo);
				Threads.push_back(CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PaintCurcle, (LPVOID)&CurrentThreadInfo, 0, NULL));
			}
			NewNumberOfThreads = 0;
			return 0;
		}
		case WM_CLOSE:
		{
			EndDialog(hwnd, 0);
			return 0;
		}
	}
	return 0;
}
