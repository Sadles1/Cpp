#include <windows.h>
#include <math.h>
#include <ctime>
#include <gdiplus.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI WinMain(HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPSTR lpCmdLine,
	int iCmdShow)
{
	//initialize GDI+
	Gdiplus::GdiplusStartupInput gdiplusstartupinput;
	ULONG_PTR gdiplusToken;
	Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusstartupinput,nullptr);
	static  TCHAR szAppName[] = TEXT("CircleDemoApp");
	HWND        hwnd;
	MSG         msg;
	WNDCLASS    wndclass;

	wndclass.style = CS_HREDRAW | CS_VREDRAW;
	wndclass.lpfnWndProc = WndProc;
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = 0;
	wndclass.hInstance = hInstance;
	wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	wndclass.lpszMenuName = NULL;
	wndclass.lpszClassName = szAppName;

	if (!RegisterClass(&wndclass))
	{
		MessageBox(NULL, TEXT("This program requires Windows NT!"),
			szAppName, MB_ICONERROR);
		return 0;
	}

	hwnd = CreateWindow(szAppName,                         // window class name
		TEXT("Comparing Circle Drawings"), // window caption
		WS_OVERLAPPEDWINDOW,               // window style
		CW_USEDEFAULT,                     // initial x position
		CW_USEDEFAULT,                     // initial y position
		CW_USEDEFAULT,                     // initial x size
		CW_USEDEFAULT,                     // initial y size
		NULL,                              // parent window handle
		NULL,                              // window menu handle
		hInstance,                         // program instance handle
		NULL);                             // creation parameters

	ShowWindow(hwnd, iCmdShow);
	UpdateWindow(hwnd);

	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	Gdiplus::GdiplusShutdown(gdiplusToken);
	return msg.wParam;
}

// the simplest way to draw a circle:
void ReallySimpleCircle(HDC hdc, LONG radius, POINT ptCenter, COLORREF crColor)
{
	LONG    cx = 0, cy;
	double  xLimit = sqrt((double)(radius * radius) / 2);

	while (cx++ <= xLimit)
	{
		cy = (LONG)floor(sqrt(radius * radius - cx * cx));
		SetPixel(hdc, cx + ptCenter.x, cy + ptCenter.y, crColor);      // 45-90    degrees
		SetPixel(hdc, cx + ptCenter.x, -cy + ptCenter.y, crColor);     // 270-315  degrees
		SetPixel(hdc, -cx + ptCenter.x, cy + ptCenter.y, crColor);     // 90-135   degrees
		SetPixel(hdc, -cx + ptCenter.x, -cy + ptCenter.y, crColor);    // 225-270  degrees
		SetPixel(hdc, cy + ptCenter.x, cx + ptCenter.y, crColor);      // 0-45     degrees
		SetPixel(hdc, cy + ptCenter.x, -cx + ptCenter.y, crColor);     // 315-360  degrees
		SetPixel(hdc, -cy + ptCenter.x, cx + ptCenter.y, crColor);     // 135-180  degrees
		SetPixel(hdc, -cy + ptCenter.x, -cx + ptCenter.y, crColor);    // 180-225  degrees
	}
} 




struct Data
{
	HDC hdc;
	POINT ptCenter;
	COLORREF color;
};

void Draw(HDC hdc)
{

	Gdiplus::Graphics gf(hdc);
	Gdiplus::Pen pen(Gdiplus::Color(255, 255, 0, 0));
	Gdiplus::SolidBrush brush(Gdiplus::Color(255, 0, 255, 0));

	gf.FillEllipse(&brush, rand() % 1000, rand() % 1000, rand() % 1000, rand() % 1000);

}

DWORD WINAPI PaintCurcle(const LPVOID lpParam)
{
	srand(time(NULL));
	CONST HDC hdc = (CONST HDC)lpParam;
	POINT ptCenter;
	int R = rand() % 255 + 1;
	int G = rand() % 255 + 1;
	int B = rand() % 255 + 1;
	for (int i = 0; true; i++)
	{
		//ptCenter.x = rand() % 1000;
		//ptCenter.y = rand() % 1000;
		//ReallySimpleCircle(hdc, rand() % 100 + 1, ptCenter, RGB(R, G, B));
		Draw(hdc);
	}
}


LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	HANDLE threads[2];
	DWORD thrId[2];
	srand(time(NULL));
	static int      cxClient, cyClient;
	HDC             hdc;
	PAINTSTRUCT     ps;
	Data data[2];
	switch (message)
	{
	case WM_SIZE:
		cxClient = LOWORD(lParam);
		cyClient = HIWORD(lParam);


		return 0;
	case WM_CREATE:

		CreateWindow(TEXT("BUTTON"), TEXT("Click"), WS_VISIBLE | WS_CHILD, 10, 10, 100, 20, hwnd, (HMENU)10000, NULL, NULL);

		return 0;
	case WM_COMMAND:
		if (LOWORD(wParam) == 10000)
		{
			ExitProcess(1);
		}
	case WM_PAINT:
		hdc = BeginPaint(hwnd, &ps);
		//threads[0] = CreateThread(NULL, 0, &PaintCurcle, hdc, 0, &thrId[0]);
		//threads[1] = CreateThread(NULL, 0, &PaintCurcle, hdc, 0, &thrId[1]);

		//EndPaint(hwnd, &ps);
		return 0;

	case WM_DESTROY:
		PostQuitMessage(0);

		return 0;
	}

	return DefWindowProc(hwnd, message, wParam, lParam);
}
